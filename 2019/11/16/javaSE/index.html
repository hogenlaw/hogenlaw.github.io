<html>
  <head><meta name="generator" content="Hexo 3.8.0">
    <title>javaSE - hogen</title>
    <link href="/images/fav.png" rel="shortcut icon">
<link href="undefined" rel="alternate" type="application/rss+xml">
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/responsive.css">
<script src="/js/jquery.js"></script>
<script src="/js/basics.js"></script>
<meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport">
<meta content="text/html; charset=utf-8" http-equiv="content-type">


  </head>
  <body>
    <header>
  <a id="go-back-home" href="/"><img src="/images/scribble.png" alt="Home" width="53" height="59"></a>
  <p>hogen</p>
  <p>Follow Excellence. Success will chase you.</p>
</header>

    <div id="container">
      <div class="block">
  
    <a class="main" href="/">Home</a>
  
    <a class="main" href="/about">About</a>
  
    <a class="main" href="https://github.com/hogenlaw">Github</a>
  
    <a class="main" href="mailto:lhg9300@foxmail.com">Email</a>
  
</div>

      <section class="paging">
  
    <div class="left">
      <a href="/2019/11/26/java-interview/">
        ‹
      </a>
    </div>
  
  
    <div class="right">
      <a href="/2019/05/28/create-value-by-information-gap/">
        ›
      </a>
    </div>
  
</section>

      <div class="content">
        <section class="post">
          <h1>
            <!-- <div class='date'>2019-11-16</div> --><!--正文的日期-->
            javaSE
          </h1>
          <p> ArrayList遍历输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; mList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">	mList.add(<span class="string">"hello"</span>);</span><br><span class="line">	mList.add(<span class="string">"张三"</span>);</span><br><span class="line">	mList.add(<span class="string">"李四"</span>);</span><br><span class="line">	mList.add(<span class="string">"王五"</span>);</span><br><span class="line">	<span class="comment">// 方法一 for循环</span></span><br><span class="line">	<span class="comment">// 方法二 增项for循环</span></span><br><span class="line">	<span class="comment">// 方法三 iterator迭代</span></span><br><span class="line">	<span class="comment">//方法四 forEach</span></span><br><span class="line">	<span class="comment">// 把字符串内容挨个输出</span></span><br><span class="line">	String str = <span class="string">"ABCDEFG"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">		System.out.println(str.charAt(i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap的遍历输出"><a href="#HashMap的遍历输出" class="headerlink" title="HashMap的遍历输出"></a>HashMap的遍历输出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Map&lt;Integer, Student&gt; hm = <span class="keyword">new</span> HashMap&lt;Integer, Student&gt;();</span><br><span class="line">	hm.put(<span class="number">1001</span>, <span class="keyword">new</span> Student(<span class="string">"张三"</span>));</span><br><span class="line">	hm.put(<span class="number">1002</span>, <span class="keyword">new</span> Student(<span class="string">"熊无"</span>));</span><br><span class="line">	hm.put(<span class="number">1003</span>, <span class="keyword">new</span> Student(<span class="string">"林之海"</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//方法一</span></span><br><span class="line">	Iterator&lt;Integer&gt; it = hm.keySet().iterator();</span><br><span class="line">	<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">		<span class="keyword">int</span> key = it.next();</span><br><span class="line">		Student values = hm.get(key);</span><br><span class="line">		System.out.println(<span class="string">"key--&gt;"</span>+key+<span class="string">"\tvalues--&gt;"</span>+values);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//方法二（推荐）</span></span><br><span class="line">	Iterator&lt;Entry&lt;Integer, Student&gt;&gt; it = hm.entrySet().iterator();</span><br><span class="line">	<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">		Entry&lt;Integer, Student&gt; entry = it.next();</span><br><span class="line">		<span class="keyword">int</span> key = entry.getKey();</span><br><span class="line">		Student s = entry.getValue();</span><br><span class="line">		System.out.println(<span class="string">"key--&gt;"</span>+key+<span class="string">"\tvalues--&gt;"</span>+s);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//增强型 for 循环</span></span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Integer, Student&gt; entry ： hm.entrySet())&#123;</span><br><span class="line">        Integer key = entry.getKey();</span><br><span class="line">		Student s = entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    hm.forEach((k,v)-&gt;System.out.println(k+<span class="string">":"</span>+v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收从键盘输入的字符，并以大写输出，遇到exit结束"><a href="#接收从键盘输入的字符，并以大写输出，遇到exit结束" class="headerlink" title="接收从键盘输入的字符，并以大写输出，遇到exit结束"></a>接收从键盘输入的字符，并以大写输出，遇到exit结束</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">	String s = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>((s=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (s.equalsIgnoreCase(<span class="string">"exit"</span>)) &#123;</span><br><span class="line">				<span class="keyword">break</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(s.toUpperCase());			</span><br><span class="line">		&#125;</span><br><span class="line">		br.close();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Comparator和Comparable"><a href="#Comparator和Comparable" class="headerlink" title="Comparator和Comparable"></a>Comparator和Comparable</h3><p>有时我们需要对List或Map集合中的数据做顺序输出处理，可以用Comparator或Comparable</p>
<ul>
<li><p>用Comparator</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//首先定义一个Bean对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">	    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	    <span class="keyword">private</span> String name;</span><br><span class="line">	    ....set、get、构造方法</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//定义一个MyComparator类并实现Comparator接口</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student s1, Student s2)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> s1.getId()-s2.getId();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对于Set集合的实现类，在主方法中做比较输出   </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Set&lt;Student&gt; set = <span class="keyword">new</span> TreeSet&lt;Student&gt;(<span class="keyword">new</span> MyComparator());</span><br><span class="line">		set.add(<span class="keyword">new</span> Student(<span class="number">1002</span>, <span class="string">"张三"</span>));</span><br><span class="line">		set.add(<span class="keyword">new</span> Student(<span class="number">1001</span>, <span class="string">"李四"</span>));</span><br><span class="line">		set.add(<span class="keyword">new</span> Student(<span class="number">1005</span>, <span class="string">"王五"</span>));</span><br><span class="line">		set.add(<span class="keyword">new</span> Student(<span class="number">1004</span>, <span class="string">"唐人"</span>));</span><br><span class="line">		set.add(<span class="keyword">new</span> Student(<span class="number">1008</span>, <span class="string">"但丁"</span>));</span><br><span class="line">		set.add(<span class="keyword">new</span> Student(<span class="number">1007</span>, <span class="string">"林俊杰"</span>));</span><br><span class="line">		set.add(<span class="keyword">new</span> Student(<span class="number">1009</span>, <span class="string">"李逸"</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (Student student : set) &#123;</span><br><span class="line">			System.out.println(student);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//对于List集合的实现类，在主方法中做比较输出</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">		list.add(<span class="keyword">new</span> Student(<span class="number">1002</span>, <span class="string">"张三"</span>));</span><br><span class="line">		list.add(<span class="keyword">new</span> Student(<span class="number">1001</span>, <span class="string">"李四"</span>));</span><br><span class="line">		list.add(<span class="keyword">new</span> Student(<span class="number">1005</span>, <span class="string">"熊志"</span>));</span><br><span class="line">		list.add(<span class="keyword">new</span> Student(<span class="number">1004</span>, <span class="string">"唐人"</span>));</span><br><span class="line">		list.add(<span class="keyword">new</span> Student(<span class="number">1008</span>, <span class="string">"但丁"</span>));</span><br><span class="line">		list.add(<span class="keyword">new</span> Student(<span class="number">1007</span>, <span class="string">"林俊杰"</span>));</span><br><span class="line">		list.add(<span class="keyword">new</span> Student(<span class="number">1009</span>, <span class="string">"李逸"</span>));</span><br><span class="line">		Collections.sort(list, <span class="keyword">new</span> MyComparator());<span class="comment">//第一个参数须是List集合的实现类</span></span><br><span class="line">		Iterator&lt;Student&gt; it = list.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</code></pre></li>
</ul>
<ul>
<li><p>用Comparable</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义Bean对象并实现Comparable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    ....set、get、构造方法</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Person p = (Person)o;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id-p.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Person&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">    <span class="comment">// 不能写成：Collection c = new ArrayList();</span></span><br><span class="line">    <span class="comment">// 这会导致49行出错，因为Collections.sort()接受的形参必须的是List接口类型的变量,</span></span><br><span class="line">    <span class="comment">// Collections.sort()不能接受Collection类型的变量，这语法上编译时是通不过的</span></span><br><span class="line">    arrayList.add(<span class="keyword">new</span> Person(<span class="number">1000</span>, <span class="string">"张思"</span>));</span><br><span class="line">    arrayList.add(<span class="keyword">new</span> Person(<span class="number">1002</span>, <span class="string">"李四"</span>));</span><br><span class="line">    arrayList.add(<span class="keyword">new</span> Person(<span class="number">1001</span>, <span class="string">"王五"</span>));</span><br><span class="line">    arrayList.add(<span class="keyword">new</span> Person(<span class="number">1004</span>, <span class="string">"小娟"</span>));</span><br><span class="line">    arrayList.add(<span class="keyword">new</span> Person(<span class="number">1008</span>, <span class="string">"老谢"</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">        System.out.println(arrayList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    java.util.Collections.sort(arrayList);<span class="comment">//49行</span></span><br><span class="line">    System.out.println(<span class="string">"排序之后的内容是:"</span>);</span><br><span class="line">    Iterator&lt;Person&gt; iterator = arrayList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.prinln(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre></li>
</ul>
<h3 id="对HashMap排序-用Collections中的API"><a href="#对HashMap排序-用Collections中的API" class="headerlink" title="对HashMap排序 用Collections中的API"></a>对HashMap排序 用Collections中的API</h3><p>但凡是对集合的操作， 我们应该保持一个原则就是能用 JDK 中的 API 就有 JDK 中的 API， 比如排序算法我们不应该 去 用 冒 泡 或 者 选 择 ， 而 是 首 先 想 到 用 Collections 集 合 工 具 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, User&gt; hm = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    hm.put(<span class="number">3</span>, <span class="keyword">new</span> User(<span class="string">"刘和广"</span>, <span class="number">42</span>));</span><br><span class="line">    hm.put(<span class="number">2</span>, <span class="keyword">new</span> User(<span class="string">"林洪川"</span>, <span class="number">33</span>));</span><br><span class="line">    hm.put(<span class="number">4</span>, <span class="keyword">new</span> User(<span class="string">"唐全兵"</span>, <span class="number">18</span>));</span><br><span class="line">    hm.put(<span class="number">1</span>, <span class="keyword">new</span> User(<span class="string">"扎伊"</span>, <span class="number">60</span>));</span><br><span class="line">    Map&lt;Integer, User&gt; map = sortMap(hm);</span><br><span class="line">    System.out.println(<span class="string">"排序后的map："</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Integer, User&gt; entry: map.entrySet())&#123;</span><br><span class="line">        System.out.println(entry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, User&gt; <span class="title">sortMap</span><span class="params">(HashMap&lt;Integer, User&gt; hm)</span> </span>&#123;</span><br><span class="line">    List&lt;Entry&lt;Integer, User&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(hm.entrySet());</span><br><span class="line">    Collections.sort(list, (o1, o2) -&gt; o1.getValue().getAge()-o2.getValue().getAge());<span class="comment">//按年龄升序</span></span><br><span class="line">    Map&lt;Integer, User&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Integer, User&gt; entry : list)&#123;</span><br><span class="line">        linkedHashMap.put(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> linkedHashMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断一个字符串中相同的字符有多少个-用HashMap"><a href="#判断一个字符串中相同的字符有多少个-用HashMap" class="headerlink" title="判断一个字符串中相同的字符有多少个(用HashMap)"></a>判断一个字符串中相同的字符有多少个(用HashMap)</h3><pre><code>public static Map&lt;Character, Integer&gt; CountsCharacter(String str) {//str:要判断的字符串
    Map&lt;Character, Integer&gt; hm = new HashMap&lt;&gt;();
    char[] ch = str.toCharArray();
    for (Character c : ch) {
        if (hm.containsKey(c)) {
            int values = hm.get(c);
            System.out.println(values);
            hm.put(c, values + 1);
        } else {
            hm.put(c, 1);
        }
    }
    return hm;
}
</code></pre><p>ArrayList、HashSet、HashMap 都是线程不安全，如果想要线程安全，Collections 工具类提供了相关的 API，可以让上面那 3 个不安全的集合变为安全的</p>
<pre><code>Collections.synchronizedCollection(c)
Collections.synchronizedList(list)
Collections.synchronizedMap(m)
Collections.synchronizedSet(s)
</code></pre><p>上面几个函数都有对应的返回值类型，传入什么类型返回什么类型。打开源码其实实现原理非常简单，就是将集合的核心方法添加上了 synchronized 关键字</p>
<h3 id="HashMap-实现发牌洗牌"><a href="#HashMap-实现发牌洗牌" class="headerlink" title="HashMap 实现发牌洗牌"></a>HashMap 实现发牌洗牌</h3><p>模拟斗地主洗牌和发牌并对牌进行排序的代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//买一副牌</span></span><br><span class="line">    String[] num = &#123;<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">"10"</span>,<span class="string">"J"</span>,<span class="string">"Q"</span>,<span class="string">"K"</span>,<span class="string">"A"</span>,<span class="string">"2"</span>&#125;;</span><br><span class="line">    String[] color = &#123;<span class="string">"方片"</span>,<span class="string">"梅花"</span>,<span class="string">"红桃"</span>,<span class="string">"黑桃"</span>&#125;;</span><br><span class="line">    Map&lt;Integer, String&gt; hm = <span class="keyword">new</span> HashMap&lt;&gt;();       <span class="comment">//存储索引和扑克牌</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();      <span class="comment">//存储索引</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;                            <span class="comment">//索引的开始值</span></span><br><span class="line">    <span class="keyword">for</span>(String s1 : num) &#123;</span><br><span class="line">        <span class="keyword">for</span>(String s2 : color) &#123;</span><br><span class="line">            hm.put(index, s2.concat(s1));        <span class="comment">//将索引和扑克牌添加到HashMap中</span></span><br><span class="line">            list.add(index);                     <span class="comment">//将索引添加到ArrayList集合中</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hm.put(index, <span class="string">"小王"</span>);</span><br><span class="line">    list.add(index);</span><br><span class="line">    index++;</span><br><span class="line">    hm.put(index, <span class="string">"大王"</span>);</span><br><span class="line">    list.add(index);</span><br><span class="line">    <span class="comment">//洗牌</span></span><br><span class="line">    Collections.shuffle(list);</span><br><span class="line">    <span class="comment">//发牌</span></span><br><span class="line">    TreeSet&lt;Integer&gt; gaojin = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    TreeSet&lt;Integer&gt; longwu = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    TreeSet&lt;Integer&gt; me = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    TreeSet&lt;Integer&gt; dipai = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= list.size() - <span class="number">3</span>) &#123;</span><br><span class="line">            dipai.add(list.get(i)); <span class="comment">//将list集合中的索引添加到TreeSet集合中会自动排序</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            gaojin.add(list.get(i));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            longwu.add(list.get(i));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            me.add(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看牌</span></span><br><span class="line">    lookPoker(<span class="string">"高进"</span>, gaojin, hm);</span><br><span class="line">    lookPoker(<span class="string">"龙五"</span>, longwu, hm);</span><br><span class="line">    lookPoker(<span class="string">"冯佳"</span>, me, hm);</span><br><span class="line">    lookPoker(<span class="string">"底牌"</span>, dipai, hm);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lookPoker</span><span class="params">(String name, TreeSet&lt;Integer&gt; ts, Map&lt;Integer, String&gt; hm)</span> </span>&#123;</span><br><span class="line">    System.out.print(name + <span class="string">"的牌是:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (Integer index : ts) &#123;</span><br><span class="line">        System.out.print(hm.get(index) + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BufferedWriter和BufferedReader"><a href="#BufferedWriter和BufferedReader" class="headerlink" title="BufferedWriter和BufferedReader"></a>BufferedWriter和BufferedReader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"e:\\Student.java"</span>)));</span><br><span class="line">    BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"e:\\a.txt"</span>)));</span><br><span class="line">    String str = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span> ((str = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bw.write(str);</span><br><span class="line">        bw.newLine();<span class="comment">// 写入一个行分隔符。</span></span><br><span class="line">    &#125;</span><br><span class="line">    bw.flush();</span><br><span class="line">    IOUtils.closeReader(br);</span><br><span class="line">    IOUtils.closeWriter(bw);</span><br><span class="line">    System.out.println(<span class="string">"文件复制成功!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件-夹-复制到另一个文件夹"><a href="#文件-夹-复制到另一个文件夹" class="headerlink" title="文件(夹)复制到另一个文件夹"></a>文件(夹)复制到另一个文件夹</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCopy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		File sourceFile = <span class="keyword">new</span> File(<span class="string">"e:\\javaIO"</span>);</span><br><span class="line">		File targetFile = <span class="keyword">new</span> File(<span class="string">"e:\\javaFile"</span>);<span class="comment">// 目标文件</span></span><br><span class="line">		System.out.println(<span class="string">"共复制以下文件!"</span>);</span><br><span class="line">		copyDirectory(sourceFile, targetFile);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyDirectory</span><span class="params">(File sourceFile, File targetFile)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (sourceFile.isFile()) &#123;<span class="comment">// 如果是文件,则直接复制</span></span><br><span class="line">			copyFile(sourceFile, <span class="keyword">new</span> File(targetFile, sourceFile.getName()));</span><br><span class="line">			System.out.println(sourceFile.getName()+<span class="string">"拷贝完成"</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是目录,则遍历</span></span><br><span class="line">			File file = <span class="keyword">new</span> File(targetFile, sourceFile.getName());<span class="comment">//创建子文件夹</span></span><br><span class="line">			file.mkdirs();</span><br><span class="line">			System.out.println(file.getName()+<span class="string">"目录创建完成!"</span>);</span><br><span class="line">			File[] files = sourceFile.listFiles();</span><br><span class="line">			<span class="keyword">for</span> (File file2 : files) &#123;</span><br><span class="line">				copyDirectory(file2, file);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//方法一：用RandomAccessFile</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(File sourceFile, File targetDir)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		RandomAccessFile rafSource = <span class="keyword">null</span>;</span><br><span class="line">		RandomAccessFile rafTarget =<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			rafSource = <span class="keyword">new</span> RandomAccessFile(sourceFile, <span class="string">"r"</span>);</span><br><span class="line">			rafTarget = <span class="keyword">new</span> RandomAccessFile(targetDir, <span class="string">"rw"</span>);</span><br><span class="line">			rafTarget.setLength(sourceFile.length());</span><br><span class="line">			<span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">4</span>];</span><br><span class="line">			<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>((length=rafSource.read(buff)) != -<span class="number">1</span>)&#123;</span><br><span class="line">				rafTarget.write(buff, <span class="number">0</span>, length);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			IOUtils.closeRandomAccessFile(rafTarget);</span><br><span class="line">			IOUtils.closeRandomAccessFile(rafSource);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//方法二</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(File sourceFile, File targetFile)</span> </span>&#123;</span><br><span class="line">		BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">		BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(sourceFile));</span><br><span class="line">			bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(targetFile));</span><br><span class="line">			<span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			<span class="keyword">int</span> length;</span><br><span class="line">			<span class="keyword">while</span> (-<span class="number">1</span> != (length = bis.read(buff))) &#123;</span><br><span class="line">				bos.write(buff, <span class="number">0</span>, length);</span><br><span class="line">			&#125;</span><br><span class="line">			bos.flush();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"路径不存在"</span>);</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"文件读写错误"</span>);</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			IOUtils.closeInputStream(bis);</span><br><span class="line">			IOUtils.closeOutputStream(bos);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="监听文件是否被修改"><a href="#监听文件是否被修改" class="headerlink" title="监听文件是否被修改"></a>监听文件是否被修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"文件无修改!"</span>);</span><br><span class="line">	<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			File filePath = <span class="keyword">new</span> File(<span class="string">"E:\\javaIO\\file01\\aa.txt"</span>);</span><br><span class="line">			<span class="keyword">long</span> time = filePath.lastModified();<span class="comment">//记录最后存放的时间</span></span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (filePath.lastModified() != time) &#123;<span class="comment">//如果修改，时间不同</span></span><br><span class="line">					System.out.println(<span class="string">"你的文件被修改了!!"</span>);</span><br><span class="line">					time = filePath.lastModified();<span class="comment">//重新获得修改后的时间</span></span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">200</span>);<span class="comment">//隔0.2s监听一次</span></span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"E:\\javaIO"</span>);</span><br><span class="line">    deleteFile(file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (file.listFiles()!=<span class="keyword">null</span> &amp;&amp; file.listFiles().length!=<span class="number">0</span>)&#123;</span><br><span class="line">		File[] files = file.listFiles();</span><br><span class="line">		<span class="keyword">for</span> (File file2 : files) &#123;</span><br><span class="line">			deleteFile(file2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"删除文件:"</span>+file.getName());</span><br><span class="line">	file.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><h5 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">33</span>, <span class="number">10</span>, -<span class="number">55</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> max = getMax(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> tmpMax = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ele : arr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ele &gt; tmpMax)</span><br><span class="line">                    tmpMax = ele;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> tmpMax;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(Supplier&lt;Integer&gt; supplier)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h5><p>Consumer 有个默认的抽象方法 accept 用于消费和默认的实现方法 andThen 用于连接多个 Consumer接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String[] arr = &#123;<span class="string">"刘和广,18"</span>, <span class="string">"林红川,22"</span>, <span class="string">"汤泉并, 33"</span>&#125;;</span><br><span class="line">       consumer(arr, (msg)-&gt;&#123;</span><br><span class="line">           String name = msg.split(<span class="string">","</span>)[<span class="number">0</span>];</span><br><span class="line">           System.out.print(<span class="string">"姓名："</span>+name);</span><br><span class="line">       &#125;, (msg)-&gt;&#123;</span><br><span class="line">           String age = msg.split(<span class="string">","</span>)[<span class="number">1</span>];</span><br><span class="line">           System.out.println(<span class="string">" 年龄："</span>+age);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">(String[] arr, Consumer&lt;String&gt; con1, Consumer&lt;String&gt; con2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (String msg : arr) &#123;</span><br><span class="line">           con1.andThen(con2).accept(msg);<span class="comment">//哪个在前面先使用哪个</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h5><p><img src="/2019/11/16/javaSE/5C1562552686311.png" alt="1562552686311"></p>
<h5 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"赵丽颖,20"</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = change(str, s -&gt; s.split(<span class="string">","</span>)[<span class="number">1</span>], Integer::parseInt, i -&gt; i + <span class="number">10</span>);</span><br><span class="line">        System.out.println(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(String str, Function&lt;String, String&gt; fun1,Function&lt;String, Integer&gt; fun2, Function&lt;Integer, Integer&gt; fun3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fun1.andThen(fun2).andThen(fun3).apply(str);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="开启一个线程"><a href="#开启一个线程" class="headerlink" title="开启一个线程"></a>开启一个线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="comment">//do something</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;.start();</span><br><span class="line">==&gt;<span class="keyword">new</span> Thread(()-&gt;&#123;...&#125;).start();</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">==&gt;Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;...&#125;);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
<h3 id="为什么重写equals一定要重写hashcode"><a href="#为什么重写equals一定要重写hashcode" class="headerlink" title="为什么重写equals一定要重写hashcode"></a>为什么重写equals一定要重写hashcode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">现在有两个Student对象：</span><br><span class="line"></span><br><span class="line">    Student s1=<span class="keyword">new</span> Student(<span class="string">"小明"</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    Student s2=<span class="keyword">new</span> Student(<span class="string">"小明"</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">此时s1.equals(s2)一定返回<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">假如只重写equals而不重写hashcode，那么Student类的hashcode方法就是Object默认的hashcode方法，由于</span><br><span class="line">默认的hashcode方法是根据对象的内存地址经哈希算法得来的，显然此时s1!=s2,故两者的hashcode不一定相等。</span><br><span class="line">然而重写了equals，且s1.equals(s2)返回<span class="keyword">true</span>，根据hashcode的规则，两个对象相等其哈希值一定相等，</span><br><span class="line">所以矛盾就产生了，因此重写equals一定要重写hashcode，而且从Student类重写后的hashcode方法中可以看出，</span><br><span class="line">重写后返回的新的哈希值与Student的两个属性有关。</span><br></pre></td></tr></table></figure>
<h3 id="生成一个四位的随机数"><a href="#生成一个四位的随机数" class="headerlink" title="生成一个四位的随机数"></a>生成一个四位的随机数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">randomText</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (set.size() &lt; <span class="number">4</span>)&#123;</span><br><span class="line">        set.add(random.nextInt(<span class="number">10</span>));</span><br><span class="line">    &#125;<span class="comment">//此时set中的数据是[值1,值2,值3, 值4]，接下来把它们存入字符串中</span></span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    set.forEach(n-&gt;sb.append(n));</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"f() start..."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            g();<span class="comment">//在synchronized代码块里面，程序卡住，放在外面会无限循环输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"g() start..."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            f();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DeadLock d = <span class="keyword">new</span> DeadLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                d.f();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                d.g();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="脏读问题"><a href="#脏读问题" class="headerlink" title="脏读问题"></a>脏读问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirtyRead</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name=<span class="string">"zhangsan"</span>;</span><br><span class="line">   <span class="keyword">private</span> String password  = <span class="string">"123"</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(String name, String password)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="comment">//模拟耗时业务逻辑</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.password = password;</span><br><span class="line">      System.out.println(<span class="string">"set data success! name:"</span>+name+<span class="string">" passsword: "</span>+password);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"get data! name: "</span>+<span class="keyword">this</span>.name+<span class="string">" password: "</span>+<span class="keyword">this</span>.password);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      DirtyRead d = <span class="keyword">new</span> DirtyRead();</span><br><span class="line">      Thread t1 = <span class="keyword">new</span> Thread(() -&gt; d.setData(<span class="string">"lisi"</span>, <span class="string">"456"</span>));</span><br><span class="line">      t1.start();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      d.getData();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁：是一种乐观思想，认为读多写少，遇到并发的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有更改这个数据，一般会使用<strong>版本号机制</strong>或<strong>CAS操作</strong>实现。</p>
<h5 id="version方式"><a href="#version方式" class="headerlink" title="version方式"></a><strong>version方式</strong></h5><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p>核心SQL代码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> x=x+<span class="number">1</span>, <span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="comment">#&#123;id&#125; and version=#&#123;version&#125;;</span></span><br></pre></td></tr></table></figure>
<h5 id="CAS-操作方式"><a href="#CAS-操作方式" class="headerlink" title="CAS 操作方式"></a><strong>CAS 操作方式</strong></h5><p>CAS是由CPU硬件实现，所以执行相当快.CAS有三个操作参数：内存地址，期望值，要修改的新值，当期望值和内存当中的值进行比较不相等的时候，表示内存中的值已经被别线程改动过，这个时候一般是做个自旋操作，即不断的重试；当相等的时候，将内存中的值改为新的值，并返回成功。 </p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁：就是悲观思想，认为写多，遇到并发的可能性高，每次拿数据的时候认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block，java 中的悲观锁就是 Synchronized,AQS 框架下的锁则是先尝试 cas 乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。</p>
<h3 id="synchronized-底层实现"><a href="#synchronized-底层实现" class="headerlink" title="synchronized 底层实现"></a>synchronized 底层实现</h3><p>被synchronized修饰的代码块底层是由一对monitorenter/monitorexit指令实现的，synchronized修饰方式会加个ACC_SYNCHRONIZED标志符，底层都是通过monitor来实现同步的，在现代JDK中，JVM提供了三种不同的monitor实现，即偏向锁、轻量锁、重量锁，当没有竞争出现时，默认使用偏向锁，JVM会利用CAS操作在对象头的标记字段(mark word)设置线程ID，表示这个对象偏向当前线程，如果有多个线程视图锁定已经被偏向过的对象，JVM就需要撤销(revoke)偏向锁，并切换到轻量锁实现，轻量锁同样依赖CAS操作mark word来视图获取锁，如果成功就使用普通的轻量级锁，否则升级为重量级锁。</p>
<p>自旋锁：是一个过渡锁，是偏向锁和轻量级锁的过渡。 当获取锁的过程中，未获取到。为了提高效率，JVM 自动执行若干次空循环，再次申请 锁，而不是进入阻塞状态的情况。称为自旋锁。自旋锁提高效率就是避免线程状态的变更。(不能算是一种锁，而是一种针对短期等待的性能优化技术)</p>
<h3 id="锁的升级降级"><a href="#锁的升级降级" class="headerlink" title="锁的升级降级"></a>锁的升级降级</h3><p>所谓锁的升级降级，就是JVM优化synchronized运行的机制，当JVM检测到不同的竞争状况时，会自动切换到不同的锁实现，这种切换就是锁的升级降级。</p>
<h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p>变量的线程可见性。在 CPU 计算过程中，会将计算过程需要的数据加载到 CPU 计算缓 存中，当 CPU 计算中断时，有可能刷新缓存，重新读取内存中的数据。在线程运行的过程 中，如果某变量被其他线程修改，可能造成数据不一致的情况，从而导致结果错误。而 volatile 修饰的变量是线程可见的，当 JVM 解释 volatile 修饰的变量时，会通知 CPU，在计算过程中， 每次使用变量参与计算时，都会检查内存中的数据是否发生变化，而不是一直使用 CPU 缓 存中的数据，可以保证计算结果的正确。 <strong>volatile 只是通知底层计算时，CPU 检查内存数据，而不是让一个变量在多个线程中同 步。</strong></p>
<h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><p>工具类型。为 Executor 线程池提供工具方法。可以快速的提供若干种线程池。如：固定 容量的，无限容量的，容量为 1 等各种线程池。 <strong>线程池是一个进程级的重量级资源。默认的生命周期和 JVM 一致。当开启线程池后， 直到 JVM 关闭为止，是线程池的默认生命周期</strong>。如果手工调用 shutdown 方法，那么线程池 执行所有的任务后，自动关闭。 </p>
<p>开始 - 创建线程池。</p>
<p> 结束 - JVM 关闭或调用 shutdown 并处理完所有的任务。</p>
<p> 类似 Arrays，Collections 等工具类型的功用。</p>
<h3 id="ForkJoinThreadPool-举例"><a href="#ForkJoinThreadPool-举例" class="headerlink" title="ForkJoinThreadPool 举例"></a>ForkJoinThreadPool 举例</h3><p>分支合并线程池。 可以递归完成复杂任务。要求可分支合并的任务必须 是 ForkJoinTask 类型的子类型。其中提供了分支和合并的能力。ForkJoinTask 类型提供了两个 抽象子类型，</p>
<p>RecursiveTask 有返回结果的分支合并任务,</p>
<p>RecursiveAction 无返回结果的分支合 并任务。（</p>
<p>Callable/Runnable）compute 方法：就是任务的执行逻辑。 ForkJoinPool 没有所谓的容量。默认都是 1 个线程。根据任务自动的分支新的子线程。 当子线程任务结束后，自动合并。所谓自动是根据 fork 和 join 两个方法实现的。 </p>
<p>应用： 主要是做科学计算或天文计算的。数据分析的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_ForkJoinThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">500</span>;<span class="comment">//定义切割的步长值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            numbers[i] = r.nextInt(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123; <span class="comment">// RecursiveAction</span></span><br><span class="line">        <span class="keyword">int</span> begin, end;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AddTask</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.begin = begin;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((end - begin) &lt; MAX_SIZE) &#123;<span class="comment">//如果比步长值小直接累加就好</span></span><br><span class="line">                <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; i++) &#123;</span><br><span class="line">                    sum += numbers[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则开启任务分治递归相加再汇总</span></span><br><span class="line">                <span class="keyword">int</span> middle = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">                AddTask task1 = <span class="keyword">new</span> AddTask(begin, middle);</span><br><span class="line">                AddTask task2 = <span class="keyword">new</span> AddTask(middle, end);<span class="comment">//为什么middle没+1？因为最终会遍历相加,在if条件中看下for循环判断呢</span></span><br><span class="line">                task1.fork();<span class="comment">// 就是用于开启新的任务的。 就是分支工作的。 就是开启一个新的线程任务。</span></span><br><span class="line">                task2.fork();</span><br><span class="line">                <span class="comment">// join - 合并。将任务的结果获取。 这是一个阻塞方法。一定会得到结果数据。</span></span><br><span class="line">                <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            result += numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//result = Arrays.stream(numbers).sum();</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"单线程加法: "</span>+result);</span><br><span class="line">        System.out.println(<span class="string">"耗时："</span>+(end-start));</span><br><span class="line"></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        AddTask task = <span class="keyword">new</span> AddTask(<span class="number">0</span>, numbers.length);</span><br><span class="line">        Future&lt;Long&gt; future = pool.submit(task);</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"多线程加法: "</span>+future.get());</span><br><span class="line">        System.out.println(<span class="string">"耗时："</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一个HelloWorld程序有几个线程"><a href="#一个HelloWorld程序有几个线程" class="headerlink" title="一个HelloWorld程序有几个线程"></a>一个HelloWorld程序有几个线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    ThreadGroup threadGroup = Thread.currentThread().getThreadGroup();</span><br><span class="line">    ThreadGroup topGroup = threadGroup;</span><br><span class="line">    <span class="keyword">while</span> (threadGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">        topGroup = threadGroup;</span><br><span class="line">        threadGroup = threadGroup.getParent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nowThreads = topGroup.activeCount();</span><br><span class="line">    Thread[] lstThreads = <span class="keyword">new</span> Thread[nowThreads];</span><br><span class="line">    topGroup.enumerate(lstThreads);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nowThreads; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"线程number："</span> + i + <span class="string">" = "</span> + lstThreads[i].getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果(如果使用的IDE是IDEA 直接运行会多一个Monitor Ctrl-break线程，这个是IDE的原因。debug模式下不会有这个线程。)</p>
<p><img src="/2019/11/16/javaSE/5C1560781810588.png" alt="1560781810588"></p>
<h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><p><strong>题目</strong>：自定义同步容器，容器容量上限为10。可以在多线程中应用，并保证数据线程安全。</p>
<p>方式一：synchronized/wait/notifyAll</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_04</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;E&gt; list = <span class="keyword">new</span> LinkedList&lt;E&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (list.size() == MAX_SIZE) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(e);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E e = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        e = list.removeFirst();</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test_04&lt;Object&gt; m = <span class="keyword">new</span> Test_04&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//容器上限10，25会超出容量限制，会等待</span></span><br><span class="line">                Object object = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">25</span>; j++) &#123;</span><br><span class="line">                    object = <span class="keyword">new</span> Object();</span><br><span class="line">                    m.put(object);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + object);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"p"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">400</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//启动10个消费者</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//每次获取5次数据</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"--&gt;"</span> + m.get());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"c"</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式二：ReentranLock/await/signalAll</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_05</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; list = <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition producer = lock.newCondition();</span><br><span class="line">    Condition consumer = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*if导致虚假唤醒状态</span></span><br><span class="line"><span class="comment">      用if会出现的问题：假定某一时刻，容器已经生产满了，这时刚好有两个生产者线程先后到达wait那行进入等待，并释放锁，</span></span><br><span class="line"><span class="comment">     * 接着有个消费者线程拿走了一个容器内对象，就意味着容器有空闲，又可以往里生产了</span></span><br><span class="line"><span class="comment">     * 此时其中一个生产者线程拿到锁对象，从wait处继续往下执行，执行到if括号结尾时另外一个线程也拿到了锁对象，从wait处继续往下执行</span></span><br><span class="line"><span class="comment">     * 这个时候问题就出来了，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() == MAX_SIZE) &#123;</span><br><span class="line">                producer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(t);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//如果用notify方法，假定当前时刻容器已经满了，本应该唤醒消费者线程进行消费，</span></span><br><span class="line">            <span class="comment">//可是不恰巧它唤醒的又是一个生产者，这个生产者进入while循环，执行wait方法，等待</span></span><br><span class="line">            consumer.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        T res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                consumer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            res = list.removeFirst();</span><br><span class="line">            count--;</span><br><span class="line">            <span class="comment">//借助条件唤醒所有的生产者</span></span><br><span class="line">            producer.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test_05&lt;Object&gt; m = <span class="keyword">new</span> Test_05&lt;Object&gt;();</span><br><span class="line">        <span class="comment">//此处跟上面一样...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReentrantLock-实现公平锁"><a href="#ReentrantLock-实现公平锁" class="headerlink" title="ReentrantLock 实现公平锁"></a>ReentrantLock 实现公平锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentranLock04</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      TestReentrantlock t = <span class="keyword">new</span> TestReentrantlock();</span><br><span class="line">      <span class="comment">//TestSync t = new TestSync();//synchronized 非公平锁</span></span><br><span class="line">      Thread t1 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">      Thread t2 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestReentrantlock</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">   <span class="comment">// 定义一个公平锁</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">         lock.lock();</span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" get lock"</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSync</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" get lock in TestSync"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过运行发现，在JDK1.8公平锁可以成功，在JDK12运行没有效果，除非加上睡眠</p>
<h3 id="一个线程笔试题"><a href="#一个线程笔试题" class="headerlink" title="一个线程笔试题"></a>一个线程笔试题</h3><p><strong>题目</strong>：自定义容器，提供新增元素和获取元素数量方法，启动两个线程，线程1向容器中新增10个数据，线程2监听容器原色数量，当容器数量为5时，线程2输出信息并终止</p>
<p>自定义容器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContain01</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        list.add(object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法一：volatile 实现， list 变量要加 volatile 关键字</p>
<p>每个线程都有自己的工作空间，当线程工作时，会把用到的变量从主内存中拷贝一份到自己的工作空间，变量的赋值使用都是在线程自己的工作内存，而变量被volatle修饰，当变量改变时强制线程执行引擎去主内存里去读取，当然线程中断的时候cpU有可能会去主存里面读取(比如在while循环里睡眠或syso)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyContain01 m = <span class="keyword">new</span> MyContain01();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;<span class="comment">//用了死循环太耗费CPU性能了,所以不推荐这种方法</span></span><br><span class="line">                <span class="keyword">if</span> (m.getSize() == <span class="number">5</span> )&#123;</span><br><span class="line">                    System.out.println(<span class="string">"容器大小为 5"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            Object object;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">                object = <span class="keyword">new</span> Object();</span><br><span class="line">                m.add(object);</span><br><span class="line">                System.out.println(<span class="string">"add contain&gt;&gt;&gt;"</span>+object);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：生产者消费者 synchronized/wait/notifyAll</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyContain01 m = <span class="keyword">new</span> MyContain01();</span><br><span class="line">        Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">if</span> (m.getSize()!=<span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();<span class="comment">//一开始执行到这里暂停直到另一个线程调用了notifyAll方法将其唤醒了</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"容器中数量为 :"</span>+m.getSize());</span><br><span class="line">                lock.notifyAll();<span class="comment">//调用notify方法唤醒另一个因调用wait陷入等待的线程，如果不调用程序一直等</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t1 "</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                Object object ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">                    object = <span class="keyword">new</span> Object();</span><br><span class="line">                    System.out.println(<span class="string">"add contain&gt;&gt;&gt;"</span>+object);</span><br><span class="line">                    m.add(object);</span><br><span class="line">                    <span class="keyword">if</span> (m.getSize() == <span class="number">5</span>)&#123;</span><br><span class="line">                        lock.notifyAll();<span class="comment">//notify并不会释放锁,此处的notify和wait不能互换</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();<span class="comment">//所以调用wait方法释放锁并停在这里</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"t2 "</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法三：CountDownLatch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        MyContain01 m = <span class="keyword">new</span> MyContain01();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (m.getSize() != <span class="number">5</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    latch.await();<span class="comment">//停在这里等待门闩开放</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"容器此时的大小为："</span>+m.getSize());</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            Object object;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">                object = <span class="keyword">new</span> Object();</span><br><span class="line">                <span class="keyword">if</span> (latch.getCount() != <span class="number">0</span>)&#123;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">                m.add(object);</span><br><span class="line">                System.out.println(<span class="string">"add contain&gt;&gt;&gt;"</span>+object);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lock-tryLock-tryLock-long-timeout-lockInterruptibly"><a href="#lock-tryLock-tryLock-long-timeout-lockInterruptibly" class="headerlink" title="lock()/tryLock()/tryLock(long timeout)/lockInterruptibly()"></a>lock()/tryLock()/tryLock(long timeout)/lockInterruptibly()</h3><p>void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经<br>被其他线程持有, <strong>将禁用当前线</strong>程, 直到当前线程获取到锁.</p>
<p> boolean  tryLock()：如果锁可用,  则获取锁,  并立即返回 true,  否则返回 false.  该方法和<br>lock()的区别在于,  tryLock()只是”试图”获取锁,  如果锁不可用,  不会导致当前线程被禁用,<br>当前线程仍然继续往下执行代码.  而 lock()方法则是一定要获取到锁,  如果锁不可用, 就一<br>直等待, 在未获得锁之前,当前线程并不继续向下执行.  </p>
<p>tryLock(long timeout)：如果锁在给定等待时间内没有被另一个线程保持，则获取该锁。 </p>
<p>lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，<br>lock 不会抛出异常，而 lockInterruptibly 会抛出异常。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_05</span> </span>&#123;</span><br><span class="line">   Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         lock.lock();</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"Test_04.m1()"</span>+i);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//lock.tryLock();</span></span><br><span class="line">         lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS);<span class="comment">//5秒内获取，能获取到，返回true</span></span><br><span class="line">         <span class="keyword">if</span> (isLocked) &#123;</span><br><span class="line">            System.out.println(<span class="string">"尝试获取锁标记成功"</span>);</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"尝试获取锁标记失败了！！"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (isLocked) &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Test_05 t = <span class="keyword">new</span> Test_05();</span><br><span class="line">      <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            t.m1();</span><br><span class="line">         &#125;;</span><br><span class="line">      &#125;.start();</span><br><span class="line">      <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            t.m2();</span><br><span class="line">         &#125;;</span><br><span class="line">      &#125;.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="把一个long类型的数据写入byte数组中-然后再从byte数组中读取出这个long类型的数据"><a href="#把一个long类型的数据写入byte数组中-然后再从byte数组中读取出这个long类型的数据" class="headerlink" title="把一个long类型的数据写入byte数组中,然后再从byte数组中读取出这个long类型的数据"></a>把一个long类型的数据写入byte数组中,然后再从byte数组中读取出这个long类型的数据</h3><p>因为网络编程中经常要把数值型数据存入byte数组中然后打包成DatagramPacket经过网络传输到目的机，目的机再从byte数组中把原数值型数据还原回来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByteArrayOutputStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception	</span>&#123;</span><br><span class="line">		<span class="keyword">long</span> n = <span class="number">9876543210L</span>;</span><br><span class="line">		ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();  </span><br><span class="line">		<span class="comment">//API:"public ByteArrayOutputStream(): 创建一个新的 byte 数组输出流。缓冲区的容量最初是 32 字节，</span></span><br><span class="line">		<span class="comment">//如有必要可增加其大小。 "9行代码一旦执行完毕，意味着两点: 1、在内存中生成了一个大小为32个字节的byte数组   </span></span><br><span class="line">		<span class="comment">//2、有一根叫做baos的管道已链接到了该byte数组中，并且可以通过这个管道向该byte数组中写入数据</span></span><br><span class="line">		<span class="comment">//虽然此时可以通过baos向baos所连接到的在内存中分配好的byte数组中写入数据，</span></span><br><span class="line">		<span class="comment">//但是ByteArrayOutputStream流并没有提供可以直接把long类型数据直接写入ByteArrayOutputStream流所连接到的byte</span></span><br><span class="line">		<span class="comment">//数组中的方法, 简单说我们没法通过baos向baos所连接到的byte数组中写入long类型的数据, </span></span><br><span class="line">		<span class="comment">//查API文档可以发现: ByteArrayOutputStream流中并没有类似writeLong()这样的方法，</span></span><br><span class="line">		<span class="comment">//但是DataOutputStream流中却有writeLong() writeFloat()等方法</span></span><br><span class="line">		</span><br><span class="line">		DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(baos);</span><br><span class="line">		</span><br><span class="line">		dos.writeLong(n);  </span><br><span class="line">		<span class="comment">//把n变量所代表的10000L在内存中的二进制代码写入dos所依附的baos管道所连接到的内存中的大小为32字节的byte数组中，</span></span><br><span class="line">		<span class="comment">//由运行结果来看，这是二进制写入，既不是把10000L转化为字符'1' '0' '0' '0' '0'写入byte数组中，</span></span><br><span class="line">		<span class="comment">//而是把10000L在内存中的总共8个字节的二进制代码写入byte数组中</span></span><br><span class="line">		</span><br><span class="line">		dos.flush();</span><br><span class="line">		<span class="keyword">byte</span>[] buf = baos.toByteArray();  </span><br><span class="line">		<span class="comment">//DataOutputStream 流中并没有toByteArray()方法，但是ByteArrayOutputStream 流中却有toByteArray()方法, </span></span><br><span class="line">		<span class="comment">//所以不可以把baos 改为dos，否则编译时会出错! ByteArrayOutputStream流中toByteArray()方法的含义，</span></span><br><span class="line">		<span class="comment">//摘自API“创建一个新分配的 byte 数组。其大小是此输出流的当前大小，并且缓冲区的有效内容已复制到该数组中”</span></span><br><span class="line"></span><br><span class="line">		ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(buf);</span><br><span class="line">		<span class="comment">//利用ByteArrayInputStream 和 DataInputStream 可以从byte数组中得到原long类型的数值10000L</span></span><br><span class="line"></span><br><span class="line">		DataInputStream dis = <span class="keyword">new</span> DataInputStream(bais);</span><br><span class="line">		<span class="keyword">long</span> l = dis.readLong();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"l = "</span> + l);</span><br><span class="line">		dos.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拷贝图片-try-with-resource"><a href="#拷贝图片-try-with-resource" class="headerlink" title="拷贝图片 try-with-resource"></a>拷贝图片 try-with-resource</h3><p>将图片读到字节数组中，再还原，源头由文件换成字节数组，baos/bais 可以理解为一段内存，所以对大小有一定的限制，由JVM回收，不用手动 close</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyImage</span><span class="params">(File srcFile, File desFile)</span></span>&#123;</span><br><span class="line">    ByteArrayOutputStream baos;</span><br><span class="line">    ByteArrayInputStream bais;</span><br><span class="line">    <span class="keyword">try</span>(FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(desFile)) &#123;</span><br><span class="line">        baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[fis.available()];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len=fis.read(buff)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//写入字节数组流</span></span><br><span class="line">            baos.write(buff, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">		baos.flush();</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[baos.size()];</span><br><span class="line">        bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">        <span class="keyword">while</span> ((tmp=bais.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(bytes, <span class="number">0</span>, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"拷贝完成..."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BufferedOutputStream-BufferedInputStream完成大容量文件的复制"><a href="#BufferedOutputStream-BufferedInputStream完成大容量文件的复制" class="headerlink" title="BufferedOutputStream / BufferedInputStream完成大容量文件的复制"></a>BufferedOutputStream / BufferedInputStream完成大容量文件的复制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBufferedInputStream</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">		BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"e:/OutputView.txt"</span>));<span class="comment">// bos 输出流有个默认的缓冲区，大小为32个字节</span></span><br><span class="line"></span><br><span class="line">			bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"F:\\music\\Cry On My Shoulder.mp3"</span>));<span class="comment">// bis 输入流有个默认的缓冲区，大小为32个字节</span></span><br><span class="line">			<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			<span class="keyword">int</span> len = bis.read(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 一定要注意，这不是从buf中读数据，而是从bis所关联到的F:\\music\\Cry On My</span></span><br><span class="line"><span class="comment">			 * Shoulder.mp3文件中读取数据， 并将读取的数据写入bis自己的默认缓冲区中，然后再将缓冲区的内容写入buf数组中，</span></span><br><span class="line"><span class="comment">			 * 每次最多向buf数组中写入1024个字节，返回实际写入buf数组的字节个数，如果读到了文件的末尾，</span></span><br><span class="line"><span class="comment">			 * 无法再向buf数组中写入数据，则返回-1</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">while</span> (-<span class="number">1</span> != len) &#123;</span><br><span class="line">				bos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * 不是写入buf数组，而是将buf数组中下标从0开始的到len-1为止的所有数据</span></span><br><span class="line"><span class="comment">				 * 写入bos所关联到的"d:/share/OutputView.txt"文件中</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				len = bis.read(buf); <span class="comment">// bis.read(buf); 等价于 bis.read(buf, 0,buf.length);</span></span><br><span class="line">			&#125;</span><br><span class="line">			bos.flush();</span><br><span class="line">			bis.close();</span><br><span class="line">			bos.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"没有找到文件!"</span>);</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"文件读写错误!"</span>);</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"文件复制成功!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Channel-Buffer"><a href="#Channel-Buffer" class="headerlink" title="Channel / Buffer"></a>Channel / Buffer</h3><table>
<thead>
<tr>
<th>IO</th>
<th style="text-align:left">NIO</th>
</tr>
</thead>
<tbody>
<tr>
<td>面向流</td>
<td style="text-align:left">面向缓冲</td>
</tr>
<tr>
<td>阻塞IO</td>
<td style="text-align:left">非阻塞IO</td>
</tr>
<tr>
<td>无</td>
<td style="text-align:left">选择器</td>
</tr>
</tbody>
</table>
<p>Java NIO的 Channel 类似流，但又有些不同：</p>
<p>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</p>
<p>通道可以异步地读写。<code>FileChannel</code>无法设置为非阻塞模式，它总是运行在阻塞模式下</p>
<p>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</p>
<p>Java NIO中的Buffer用于和NIO通道进行交互。缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File sourFile = <span class="keyword">new</span> File(<span class="string">"d:/spring 事务学习.pdf"</span>);</span><br><span class="line">    File targetFile = <span class="keyword">new</span> File(<span class="string">"d:/learning"</span>, sourFile.getName());</span><br><span class="line">    <span class="comment">//直接用这个</span></span><br><span class="line">    <span class="comment">//Files.copy(Paths.get(sourFile.toString()),Paths.get(targetFile.toString()),StandardCopyOption.REPLACE_EXISTING);</span></span><br><span class="line">    </span><br><span class="line">    RandomAccessFile rafRead = <span class="keyword">new</span> RandomAccessFile(sourFile,<span class="string">"rw"</span>);</span><br><span class="line">    RandomAccessFile rafWrite = <span class="keyword">new</span> RandomAccessFile(targetFile,<span class="string">"rwd"</span>);</span><br><span class="line">    FileChannel fromChannel = rafRead.getChannel();</span><br><span class="line">    FileChannel toChannel = rafWrite.getChannel();</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> len ;</span><br><span class="line">    System.out.println(fromChannel.size());<span class="comment">//文件总大小</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    写数据到Buffer有两种方式：</span></span><br><span class="line"><span class="comment">        从Channel写到Buffer。fromChannel.read(buffer)</span></span><br><span class="line"><span class="comment">        通过Buffer的put()方法写到Buffer里。buffer.put()</span></span><br><span class="line"><span class="comment">    从Buffer中读取数据有两种方式：</span></span><br><span class="line"><span class="comment">        从Buffer读取数据到Channel。fromChannel.write(buffer)</span></span><br><span class="line"><span class="comment">        使用get()方法从Buffer中读取数据。buffer.get()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//可以用这种方式</span></span><br><span class="line">    <span class="keyword">while</span> ((len=fromChannel.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        buffer.flip();<span class="comment">//设置buffer切换模式为读模式</span></span><br><span class="line">        rafWrite.write(buffer.array(), <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.clear();<span class="comment">//清空缓冲区</span></span><br><span class="line">    <span class="comment">//或是这种方式</span></span><br><span class="line">    toChannel.transferFrom(fromChannel,<span class="number">0</span>, fromChannel.size());</span><br><span class="line">    <span class="comment">//亦或是这种都可以实现文件拷贝</span></span><br><span class="line">    fromChannel.transferTo(<span class="number">0</span>, fromChannel.size(), toChannel);</span><br><span class="line">    System.out.println(<span class="string">"拷贝完成.."</span>);</span><br><span class="line">    rafWrite.close();</span><br><span class="line">    rafRead.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>&#125;;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">    System.out.println(<span class="string">"放数据之前："</span>+byteBuffer);</span><br><span class="line">    byteBuffer.put(buff);</span><br><span class="line">    System.out.println(<span class="string">"放数据之后："</span>+byteBuffer);</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    System.out.println(<span class="string">"重置游标之后："</span>+byteBuffer);</span><br><span class="line">    System.out.println(<span class="string">"buffer有效数据大小："</span>+byteBuffer.remaining());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;byteBuffer.remaining(); i++)&#123;</span><br><span class="line">        System.out.println(i+<span class="string">" --&gt; "</span> + byteBuffer.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/16/javaSE/5C1560859424287.png" alt="1560859424287"></p>
<p><img src="/2019/11/16/javaSE/5C1560863293112.png" alt="1560863293112"></p>
<h3 id="Selector-选择器"><a href="#Selector-选择器" class="headerlink" title="Selector 选择器"></a>Selector 选择器</h3><p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。<br>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。<br>应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p>
<h3 id="谈谈对-Java-平台的理解"><a href="#谈谈对-Java-平台的理解" class="headerlink" title="谈谈对 Java 平台的理解"></a>谈谈对 Java 平台的理解</h3><p>面向对象、GC、丰富的类库(集合 IO NIO 线程 网络 并发)、JDK\JRE。</p>
<p>Java是解释执行这句话并不准确，我们开发的源代码首先通过 Javac编译成.class字节码文件，然后再通过虚拟机<strong>解析或编译</strong>运行：</p>
<p>1）解析:.class文件经过JVM内嵌的解析器解析执行。<br>2）编译:我们大多数情况使用的 Oracle JDK 提供的 Hotspot JVM，都提供了 JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，JIT 能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于编译执行，而不是解释执行了。</p>
<h3 id="Linux-查找日志常用命令和技巧"><a href="#Linux-查找日志常用命令和技巧" class="headerlink" title="Linux 查找日志常用命令和技巧"></a>Linux 查找日志常用命令和技巧</h3><p>#查询最后100行日志<br><code>tail -n 100 info.log</code><br>查询从100行之后的所有日志<br><code>tail -n +100 info.log</code><br>查询日志文件中的头10行日志;<br><code>head -n 10 info.log</code><br>查询日志文件除了最后10行的其他所有日志;<br><code>head -n -10 info.log</code><br>获取关键字的行号  -n 显示行号<br><code>cat -n test.log |grep &quot;关键字&quot;</code><br>查找指定行号63829附近的日志，tail -n +63820表示查询63820行之后的日志，head -n 20 则表示在前面的查询结果里再查前20条记录<br><code>cat -n test.log |tail -n +63820|head -n 20</code><br>查找2017-07-03 21:21 ~ 2017-07-03 21:22内的日志<br><code>sed -n &#39;/2017-07-03 21:21/,/2017-07-03 21:22/p&#39; info.log</code><br>查找2017-07-03 21:21:34 ~ 2017-07-03 21:21:39内的所有日志<br><code>sed -n &#39;/2017-07-03 21:21:34/,/2017-07-03 21:21:39/p&#39; info.log</code></p>
<h3 id="String-常量池"><a href="#String-常量池" class="headerlink" title="String 常量池"></a>String 常量池</h3><p>String 类型的常量池比较特殊。它的主要使用方法有两种：</p>
<ul>
<li><p>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</p>
</li>
<li><p>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：<strong>如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"计算机"</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = <span class="string">"计算机"</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//计算机</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，</span></span><br><span class="line">System.out.println(s3 == s2);<span class="comment">//true，因为两个都是常量池中的 String 对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>intern</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a =<span class="keyword">new</span> String(<span class="string">"abc"</span>).intern();</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">"abc"</span>).intern();</span><br><span class="line">System.out.println(a==b);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  new String(“abc”)是会创建两个对象的，一个是堆对象，一个是常量池中的对象，intern会去判断常量池中是否有，这个时候是有的，所以不会创建，而是改变s1的引用。</p>
<p>  String str = new String(“abc”);这个语句会在字符串常量池中和堆中都生成变量，但str指向堆中的变量；如果调用intern方法，则str指向字符串常量池中的变量，此时堆中的变量会被垃圾回收</p>
<blockquote>
<p>String s1=”123”;字符串”123”已经被放入常量池，那要定义一个和s1一样的，用String s2=s1;不就好了，为什么还要用intern方法?</p>
<p>我们在类对象中的String属性是在堆内存中开辟的地址空间，所以如果不用intern方法，新生产的对象中的String字段的属性是引用堆内存的地址，而堆内存中创建的字段即使value值一样也会开辟新地址空间。如果使用intern方法，则会引用常量池中的引用，而如果常量池中如果存在字符串对象，则复用，不会再创建了。</p>
</blockquote>
<ul>
<li><p>字符串拼接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"str"</span>;</span><br><span class="line">String str2 = <span class="string">"ing"</span>;</span><br><span class="line"></span><br><span class="line">String str3 = <span class="string">"str"</span> + <span class="string">"ing"</span>;<span class="comment">//常量池中的对象，编译器自动优化String str3 = "string"</span></span><br><span class="line">String str4 = str1 + str2; <span class="comment">//在堆上创建的新的对象	  </span></span><br><span class="line">String str5 = <span class="string">"string"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/16/javaSE/5C1560075257086.png" alt="1560075257086"></p>
<p>尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。jdk1.6常量池再方法区，jdk1.7常量池在堆区，jdk1.8在元空间</p>
</li>
</ul>
<h3 id="Java-垃圾回收"><a href="#Java-垃圾回收" class="headerlink" title="Java 垃圾回收"></a>Java 垃圾回收</h3><p>垃圾回收，顾名思义是将已经分配出去的但不再使用的内存回收起来以便再次分配，此处的垃圾指的是死亡的对象占据的空间，大体分为两个步骤 : 先标记哪些对象已死亡，再进行垃圾回收</p>
<h4 id="判断对象是否死亡"><a href="#判断对象是否死亡" class="headerlink" title="判断对象是否死亡"></a>判断对象是否死亡</h4><h6 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h6><p>为每个对象添加一个引用计数器，用来统计指向该对象的引用个数，一旦某个对象的引用计数器为0，则说明该对象已死亡，可以回收了</p>
<h6 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h6><p>目前 <strong>Java 虚拟机的主流垃圾回收器采取的是可达性分析算法</strong>。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。</p>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><h6 id="清除（sweep）"><a href="#清除（sweep）" class="headerlink" title="清除（sweep）"></a>清除（sweep）</h6><p>把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。</p>
<p>清除这种回收方式的原理及其简单，但是有两个缺点。一是会造成内存碎片。由于 Java 虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。</p>
<h6 id="复制（copy）"><a href="#复制（copy）" class="headerlink" title="复制（copy）"></a>复制（copy）</h6><p>把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。</p>
<p>这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，copy 算法的效率会大大降低。 </p>
<h6 id="压缩（compact）"><a href="#压缩（compact）" class="headerlink" title="压缩（compact）"></a>压缩（compact）</h6><p>把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。</p>
<h6 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h6><p>当 Eden空间耗尽，Java虚拟机便会触发一次Minor GC收集新生代的垃圾，存活下来的对象会被复制到Survivor区(from区)，经过一次Minor GC后Eden区有空闲了，当再次达到触发条件时，Eden 区域的存活对象和 From 区域对象会被复制到to Survivor区中，并且存活的年龄计数加 1 ，然后交换from 和 to 指针，如果一个对象被复制的次数超过15，该对象会被晋升至老年代。</p>
<p>1、大部分对象创建都是在Eden的，除了个别大对象外。<br>2、Minor GC开始前，to-survivor是空的，from-survivor是由对象的。<br>3、Minor GC后，Eden的存活对象都copy到to-survivor中，而在from-survivor区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值的对象会被移动到年老代中，没有达到阈值的对象会被复制到to-survivor区域。<br>4、from-survivor清空，成为新的to-survivor，带有对象的to-survivor变成新的from-survivor。重复回到步骤2</p>
<p><img src="/2019/11/16/javaSE/5C1561022352124.png" alt="1561022352124"></p>
<h6 id="为什么标记的时候要stop-the-world？"><a href="#为什么标记的时候要stop-the-world？" class="headerlink" title="为什么标记的时候要stop the world？"></a>为什么标记的时候要stop the world？</h6><p>是为了避免在标记的时候又有对象在堆内生成，如果这个对象对其他未标记对象有引用，而这个时候由于gc而清理掉了未标记的对象，会有问题</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul>
<li><p>懒汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton intance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="comment">/*synchronized*/</span> <span class="function">Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>懒汉式要想在多线程情况下实现线程安全可以加 synchronized 关键字，但这样一来会降低整个访问速度，这种情况下可以考虑双重检查加锁，即可以实现线程安全，又能使性能不受很大影响</p>
</li>
<li><p>饿汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton intance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>饿汉式是线程安全的，intance 静态变量虚拟机保证只会加载一次，在装载类的时候是不会发生并发的</p>
</li>
<li><p>双重 检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">				<span class="keyword">if</span>(intance == <span class="keyword">null</span>)&#123;</span><br><span class="line">					instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Lazy initialization holder class </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">	private Singleton()&#123;&#125;</span><br><span class="line">	//类级内部类，该内部类的实例与外部类的实例没有绑定关系，而且只是调用时才会装载，从而实现了延迟加载</span><br><span class="line">	private static class SingletonHolder&#123;</span><br><span class="line">		//静态初始化器，由JVM保证线程安全</span><br><span class="line">		private static Singleton instance = new Instance();</span><br><span class="line">	&#125;</span><br><span class="line">	public static Singleton getInstance()&#123;</span><br><span class="line">		return SingletonHolder.instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>提供一个创建对象实例的功能而无需关心其具体实现，被创建实例的类型可以是接口、抽象类或具体的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义接口，该接口可以通过简单工厂来创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义接口的两个实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplA</span> <span class="keyword">implements</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"ImplA is: "</span>+ str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplB</span> <span class="keyword">implements</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"ImplB is: "</span>+ str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//工厂类</span><br><span class="line">public class Factory&#123;</span><br><span class="line">	public static Api createApi(int condition)&#123;</span><br><span class="line">		Api api = null;</span><br><span class="line">		//当然如果只有一个实现类就直接 return 就好了</span><br><span class="line">		if(condition == 1)&#123;</span><br><span class="line">			api = new ImplA();</span><br><span class="line">		&#125;else if(condition == 2)&#123;</span><br><span class="line">			api = new ImplB();</span><br><span class="line">		&#125;</span><br><span class="line">		return api;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Client&#123;</span><br><span class="line">	//使用简单工厂，就不用 Api api = new ImplA(),这样，从客户端看，</span><br><span class="line">	//它根本不知道具体的实现类是什么，也不知道是如何实现的，封装隔离性也就体现出来了</span><br><span class="line">	Api api = Factory.createApi(1);</span><br><span class="line">	api.operation(&quot;使用简单创建工厂&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p><strong>场景</strong>：组装电脑，通常会有两种选择。要么自己去电子市场把配件买回来自己 DIY，要么找专业的装机公司，把具体的要求提出来，让后等着拿电脑就是，在这里，装机公司就相当于外观模式</p>
<p><strong>定义</strong>：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</p>
<p>。。。。</p>

          <br>
<p>hogen</p>
<div class="date">2019-11-16</div>

        </section>
      </div>
      
      <div class="block">
  
    <a class="main" href="/">Home</a>
  
    <a class="main" href="/about">About</a>
  
    <a class="main" href="https://github.com/hogenlaw">Github</a>
  
    <a class="main" href="mailto:lhg9300@foxmail.com">Email</a>
  
</div>

    </div>
    <footer>
  <span class="muted">Powered by hogenlaw</span>
</footer>

  </body>
</html>
